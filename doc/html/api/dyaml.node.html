<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>dyaml.node - D:YAML 0.1 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<img id="logo" alt="D:YAML logo" src="images/logo.png"><a id="main-heading" href="index.html">D:YAML 0.1 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul><li><a href="../index.html">Documentation home</a></li>
</ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="dyaml.constructor.html">dyaml.constructor</a></li>
<li><a href="dyaml.exception.html">dyaml.exception</a></li>
<li><a href="dyaml.loader.html">dyaml.loader</a></li>
<li><a href="dyaml.node.html">dyaml.node</a></li>
<li><a href="dyaml.resolver.html">dyaml.resolver</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>dyaml.node</h1>
<!-- Generated by Ddoc from dyaml/node.d -->
<p>Node of a YAML document. Used to read YAML data once it's loaded.</p>

<dl><dt class="d_decl">class <a name="NodeException"></a><span class="ddoc_psymbol">NodeException</span>: dyaml.exception.YAMLException;
</dt>
<dd><p>Exception thrown at node related errors.</p>

</dd>
<dt class="d_decl">struct <a name="YAMLNull"></a><span class="ddoc_psymbol">YAMLNull</span>;
</dt>
<dd><p>Null YAML type. Used in nodes with null values.</p>

</dd>
<dt class="d_decl">struct <a name="Node"></a><span class="ddoc_psymbol">Node</span>;
</dt>
<dd><p>YAML node.
</p>
<p>This is a pseudo-dynamic type that can store any YAML value, including sequence
 or a mapping of nodes. You can get data from a <a name="Node"></a><span class="ddoc_psymbol">Node</span> directly or iterate over it
 if it's a sequence or a mapping.</p>

<dl><dt class="d_decl">struct <a name="Pair"></a><span class="ddoc_psymbol">Pair</span>;
</dt>
<dd><p><a name="Pair"></a><span class="ddoc_psymbol">Pair</span> of YAML nodes, used in mappings.</p>

<dl><dt class="d_decl">Node <a name="key"></a><span class="ddoc_psymbol">key</span>;
</dt>
<dd><p>Key node.</p>

</dd>
<dt class="d_decl">Node <a name="value"></a><span class="ddoc_psymbol">value</span>;
</dt>
<dd><p>Value node.</p>

</dd>
<dt class="d_decl">bool <a name="equals"></a><span class="ddoc_psymbol">equals</span>(ref Pair <b>rhs</b>);
</dt>
<dd><p>Test for equality with another Pair.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">const @property bool <a name="isValid"></a><span class="ddoc_psymbol">isValid</span>();
</dt>
<dd><p>Is this node valid (initialized)? </p>

</dd>
<dt class="d_decl">const @property bool <a name="isScalar"></a><span class="ddoc_psymbol">isScalar</span>();
</dt>
<dd><p>Is this node a scalar value?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isSequence"></a><span class="ddoc_psymbol">isSequence</span>();
</dt>
<dd><p>Is this node a sequence of nodes?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isMapping"></a><span class="ddoc_psymbol">isMapping</span>();
</dt>
<dd><p>Is this node a mapping of nodes?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isUserType"></a><span class="ddoc_psymbol">isUserType</span>();
</dt>
<dd><p>Is this node a user defined type?</p>

</dd>
<dt class="d_decl">bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(T)(ref T <b>rhs</b>);
</dt>
<dd><p>Equality test.
</p>
<p>If T is Node, recursively compare all
 subnodes and might be quite expensive if testing entire documents.
<br>

 If T is not Node, convert the node to T and test equality with that.

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//node is a Node that contains integer 42
</span> <span class="d_keyword">assert</span>(node == 42);
 <span class="d_keyword">assert</span>(node == <span class="d_string">"42"</span>);
 <span class="d_keyword">assert</span>(node != <span class="d_string">"43"</span>);
</pre>

</div>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>rhs</td>
<td valign=top>Variable to test equality with.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr"><b>true</b> if equal, <b>false</b> otherwise.</div>

</dd>
<dt class="d_decl">T <a name="get"></a><span class="ddoc_psymbol">get</span>(T)();
</dt>
<dd><p>Get the value of the node as specified type.
</p>
<p>If the specifed type does not match type in the node,
 conversion is attempted if possible.
<br>

 Timestamps are stored as std.datetime.SysTime.
 Binary values are decoded and stored as ubyte[].
<br>

 <br><b>Mapping default values:</b>
<br>

 <div class="pbr">The '=' key can be used to denote the default value of a mapping.
 This can be used when a node is scalar in early versions of a program,
 but is replaced by a mapping later. Even if the node is a mapping, the
 <a name="get"></a><span class="ddoc_psymbol">get</span> method can be used as if it was a scalar if it has a default value.
 This way, new YAML files where the node is a mapping can still be read
 by old versions of the program, which expects the node to be a scalar.
 </div>

</p>
<b>Examples:</b><div class="pbr">Automatic type conversion:
<pre class="d_code"> <span class="d_comment">//node is a node that contains integer 42
</span> <span class="d_keyword">assert</span>(node.<span class="d_psymbol">get</span>!<span class="d_keyword">int</span> == 42);
 <span class="d_keyword">assert</span>(node.<span class="d_psymbol">get</span>!string == <span class="d_string">"42"</span>);
 <span class="d_keyword">assert</span>(node.<span class="d_psymbol">get</span>!<span class="d_keyword">double</span> == 42.0);
</pre>

</div>
<b>Returns:</b><div class="pbr">Value of the node as specified type.

</div>
<b>Throws:</b><div class="pbr">NodeException if unable to convert to specified type.</div>

</dd>
<dt class="d_decl">void <a name="getToVar"></a><span class="ddoc_psymbol">getToVar</span>(T)(out T <b>target</b>);
</dt>
<dd><p>Write the value of the node to target.
</p>
<p>If the type of target does not match type of the node,
 conversion is attempted, if possible.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>target</td>
<td valign=top>Variable to write to.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr">NodeException if unable to convert to specified type.</div>

</dd>
<dt class="d_decl">@property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><p>If this is a sequence or a mapping, return its <a name="length"></a><span class="ddoc_psymbol">length</span>.
</p>
<p>Otherwise, throw NodeException.

</p>
<b>Returns:</b><div class="pbr">Number of elements in a sequence or key-value pairs in a mapping.

</div>
<b>Throws:</b><div class="pbr">NodeException if this is not a sequence nor a mapping.</div>

</dd>
<dt class="d_decl">Node <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(T)(in T <b>index</b>);
</dt>
<dd><p>Get the element with specified index.
</p>
<p>If the node is a sequence, index must be integral.
<br>

 If the node is a mapping, return the value corresponding to the first
 key equal to index, even after conversion. I.e; node["12"] will
 return value of the first key that equals "12", even if it's an integer.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>index</td>
<td valign=top>Index to use.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Value corresponding to the index.

</div>
<b>Throws:</b><div class="pbr">NodeException if the index could not be found.</div>

</dd>
<dt class="d_decl">int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(T)(int delegate(ref T) <b>dg</b>);
</dt>
<dd><p>Iterate over a sequence, getting each element as T.
</p>
<p>If T is Node, simply iterate over the nodes in the sequence.
 Otherwise, convert each node to T during iteration.

</p>
<b>Throws:</b><div class="pbr">NodeException if the node is not a sequence or an
          element could not be converted to specified type.</div>

</dd>
<dt class="d_decl">int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(K, V)(int delegate(ref K, ref V) <b>dg</b>);
</dt>
<dd><p>Iterate over a mapping, getting each key/value as K/V.
</p>
<p>If the K and/or V is Node, simply iterate over the nodes in the mapping.
 Otherwise, convert each key/value to T during iteration.

</p>
<b>Throws:</b><div class="pbr">NodeException if the node is not a mapping or an
          element could not be converted to specified type.</div>

</dd>
<dt class="d_decl">alias <a name="isInt"></a><span class="ddoc_psymbol">isInt</span>;
</dt>
<dd><p>Is the value an integer of some kind?</p>

</dd>
<dt class="d_decl">alias <a name="isFloat"></a><span class="ddoc_psymbol">isFloat</span>;
</dt>
<dd><p>Is the value a floating point number of some kind?</p>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2011. Based on <a href="http://www.pyyaml.org">PyYAML</a> by Kirill Simonov. |
Page generated by Autodoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
